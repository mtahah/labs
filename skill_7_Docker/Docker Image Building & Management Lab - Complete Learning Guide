# Docker Image Building & Management Lab - Complete Learning Guide

## Big Picture Overview & Learning Context

### What You'll Master in This Lab:
Docker image management is at the heart of containerization. This lab teaches you the complete lifecycle of Docker images - from creating efficient, optimized images to distributing them globally.

### Why This Matters:
- **Image Size Impact**: A 200MB vs 15MB image means 13x faster deployments
- **Layer Optimization**: Each Dockerfile instruction creates a layer - fewer layers = better performance
- **Build Context**: Unnecessary files slow builds and increase security risks
- **Registry Management**: Docker Hub is like GitHub for containers - essential for sharing
- **Production Ready**: These skills are crucial for real-world DevOps workflows

### Real-World Context:
In production, you'll build images that get pulled thousands of times across different environments. Every MB matters when scaling applications globally.

---

## Task 1: Docker Image Layer Optimization

### Learning Chunk 1A: Understanding the Problem

```bash
echo "=== TASK 1: Docker Image Layer Optimization ==="
echo "🎯 LEARNING GOAL: Understand why image optimization matters"
echo ""
echo "Docker images are built in layers - like a cake with multiple layers"
echo "Each Dockerfile instruction (RUN, COPY, ADD) creates a new layer"
echo "More layers = larger images = slower deployments = higher costs"
echo ""
echo "Let's first create our workspace and see the problem..."

# Create project directory
mkdir docker-optimization-lab
cd docker-optimization-lab

echo "✅ Created workspace: docker-optimization-lab"
echo "📁 Current location: $(pwd)"
```

### Learning Chunk 1B: Create Sample Web Content

```bash
echo ""
echo "=== Creating Sample Web Application ==="
echo "We're building a simple HTML page to demonstrate image optimization"
echo "This simulates a real web application that needs to be containerized"

# Create a simple HTML file
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Docker Optimization Lab</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 600px; margin: 0 auto; }
        h1 { color: #2c3e50; }
        .info { background: #ecf0f1; padding: 20px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Welcome to Docker Optimization Lab</h1>
        <div class="info">
            <p>This is a sample web application running in a Docker container.</p>
            <p>Image optimization techniques help reduce size and improve performance.</p>
        </div>
    </div>
</body>
</html>
EOF

echo "✅ Created index.html with styled content"
echo "📄 Let's preview our HTML content:"
head -10 index.html
echo "..."
echo "(HTML file created with styling and content)"
```

### Learning Chunk 1C: Create Non-Optimized Dockerfile

```bash
echo ""
echo "=== Creating NON-OPTIMIZED Dockerfile ==="
echo "❌ BAD PRACTICE: This Dockerfile demonstrates what NOT to do"
echo "Problems we're introducing:"
echo "• Using large base image (ubuntu:20.04 instead of alpine)"
echo "• Multiple separate RUN commands (creates many layers)"
echo "• Installing unnecessary packages"
echo "• Not cleaning up package cache efficiently"

# Create a non-optimized Dockerfile
cat > Dockerfile.unoptimized << 'EOF'
FROM ubuntu:20.04

# Update package list
RUN apt-get update

# Install nginx
RUN apt-get install -y nginx

# Install curl for testing
RUN apt-get install -y curl

# Install vim for editing
RUN apt-get install -y vim

# Clean package cache
RUN apt-get clean

# Remove default nginx page
RUN rm /var/www/html/index.nginx-debian.html

# Copy our HTML file
COPY index.html /var/www/html/

# Expose port 80
EXPOSE 80

# Start nginx
CMD ["nginx", "-g", "daemon off;"]
EOF

echo "✅ Created Dockerfile.unoptimized"
echo "📋 Let's examine what we just created:"
echo "This Dockerfile has $(grep -c '^RUN' Dockerfile.unoptimized) separate RUN commands"
echo "Each RUN command creates a separate layer!"
```

### Learning Chunk 1D: Build and Analyze Non-Optimized Image

```bash
echo ""
echo "=== Building NON-OPTIMIZED Image ==="
echo "🔨 Now let's build this inefficient image and see its size"

# Build the non-optimized image
docker build -f Dockerfile.unoptimized -t webapp-unoptimized:v1 .

echo ""
echo "📊 Let's check the size of our unoptimized image:"

# Check the image size
docker images webapp-unoptimized:v1

echo ""
echo "💡 ANALYSIS: Notice the image size above"
echo "The ubuntu:20.04 base image alone is quite large"
echo "Each RUN command added more layers and size"
```

### Learning Chunk 1E: Create Optimized Dockerfile

```bash
echo ""
echo "=== Creating OPTIMIZED Dockerfile ==="
echo "✅ BEST PRACTICE: Now let's do it the right way"
echo "Optimizations we're applying:"
echo "• Using nginx:alpine (much smaller base image ~15MB vs ~72MB)"
echo "• Minimal layers - only what's necessary"
echo "• Base image already has nginx configured"
echo "• No unnecessary packages or tools"

# Create an optimized Dockerfile
cat > Dockerfile.optimized << 'EOF'
FROM nginx:alpine

# Copy our HTML file
COPY index.html /usr/share/nginx/html/

# Expose port 80
EXPOSE 80

# nginx:alpine already has the correct CMD
EOF

echo "✅ Created Dockerfile.optimized"
echo "📋 Compare the files:"
echo "Unoptimized: $(wc -l < Dockerfile.unoptimized) lines"
echo "Optimized: $(wc -l < Dockerfile.optimized) lines"
echo "Fewer lines often means better optimization!"
```

### Learning Chunk 1F: Build and Compare Optimized Image

```bash
echo ""
echo "=== Building OPTIMIZED Image ==="
echo "🔨 Building the streamlined version..."

# Build the optimized image
docker build -f Dockerfile.optimized -t webapp-optimized:v1 .

echo ""
echo "📊 IMAGE SIZE COMPARISON:"
echo "Let's see the dramatic difference..."

# Compare image sizes
docker images | grep webapp

echo ""
echo "💡 OPTIMIZATION RESULTS ANALYSIS:"
echo "The size difference should be dramatic (potentially 80-90% reduction)"
echo "Alpine Linux is security-focused and minimal"
echo "nginx:alpine comes pre-configured, reducing complexity"
```

### Learning Chunk 1G: Multi-Stage Build Setup

```bash
echo ""
echo "=== Advanced Optimization: Multi-Stage Builds ==="
echo "🎓 ADVANCED CONCEPT: Multi-stage builds"
echo "Used for applications that need build tools but not in final image"
echo "Example: Node.js apps need npm to install dependencies"
echo "But production image only needs the compiled app, not npm/build tools"
echo ""
echo "Let's create a Node.js example to demonstrate..."

# Create a simple Node.js application
cat > package.json << 'EOF'
{
  "name": "docker-optimization-demo",
  "version": "1.0.0",
  "description": "Demo app for Docker optimization",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.0"
  }
}
EOF

echo "✅ Created package.json for Node.js app"
echo "📦 This defines our application dependencies"
```

### Learning Chunk 1H: Create Node.js Server

```bash
echo ""
echo "=== Creating Express Server ==="
echo "Building a simple web server to demonstrate multi-stage builds"

# Create a simple Express server
cat > server.js << 'EOF'
const express = require('express');
const path = require('path');
const app = express();
const PORT = 3000;

// Serve static files
app.use(express.static('.'));

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
EOF

echo "✅ Created server.js - Express web server"
echo "🌐 This server will serve our HTML file on port 3000"
echo "📄 Let's verify our server code:"
head -5 server.js
```

### Learning Chunk 1I: Multi-Stage Dockerfile

```bash
echo ""
echo "=== Creating Multi-Stage Dockerfile ==="
echo "🎯 MULTI-STAGE CONCEPT:"
echo "Stage 1 (builder): Install dependencies, has all build tools"
echo "Stage 2 (production): Copy only what's needed, no build tools"
echo "Result: Much smaller final image"

# Create a multi-stage Dockerfile
cat > Dockerfile.multistage << 'EOF'
# Build stage
FROM node:16-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install --only=production

# Production stage
FROM node:16-alpine AS production

WORKDIR /app

# Copy only necessary files from builder stage
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./
COPY server.js ./
COPY index.html ./

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

USER nodejs

EXPOSE 3000

CMD ["npm", "start"]
EOF

echo "✅ Created Dockerfile.multistage"
echo "🔍 KEY CONCEPTS EXPLAINED:"
echo "• AS builder: Names the first stage"
echo "• COPY --from=builder: Copies from previous stage"
echo "• Two FROM statements = two stages"
echo "• Final image only contains second stage"
```

### Learning Chunk 1J: Build Multi-Stage and Compare All

```bash
echo ""
echo "=== Building Multi-Stage Image ==="
echo "🔨 Building the multi-stage image..."

# Build the multi-stage image
docker build -f Dockerfile.multistage -t webapp-multistage:v1 .

echo ""
echo "📊 COMPLETE SIZE COMPARISON:"
echo "Now let's see all our images side by side..."

# Compare all image sizes
docker images | grep webapp

echo ""
echo "💡 MULTI-STAGE BENEFITS ANALYSIS:"
echo "Multi-stage builds separate build-time and runtime dependencies"
echo "Build stage can be large (has compilers, build tools)"
echo "Production stage is minimal (only runtime dependencies)"
echo "Security benefit: fewer attack vectors in production image"
```

---

## Task 2: Docker .dockerignore File Management

### Learning Chunk 2A: Understanding Build Context Problem

```bash
echo ""
echo "=== TASK 2: Managing Build Context with .dockerignore ==="
echo "🎯 LEARNING GOAL: Understand why .dockerignore is crucial"
echo ""
echo "PROBLEM: Docker sends ALL files in directory to build context"
echo "This includes logs, temporary files, git history, etc."
echo "Larger build context = slower builds + potential security risks"
echo ""
echo "SOLUTION: .dockerignore works like .gitignore"
echo "It excludes files from being sent to Docker daemon"
echo ""
echo "Let's create some 'junk' files to demonstrate..."
```

### Learning Chunk 2B: Create Various File Types

```bash
echo ""
echo "=== Creating Files to Simulate Real Project ==="
echo "Real projects have logs, temporary files, docs, etc."
echo "Let's create these to show the .dockerignore effect"

# Create some log files
mkdir logs
echo "Error log content" > logs/error.log
echo "Access log content" > logs/access.log
echo "Debug information" > logs/debug.log

echo "✅ Created log files (should not be in container)"

# Create temporary files
echo "Temporary data" > temp.txt
echo "Cache data" > cache.tmp
echo "Build artifacts" > build.out

echo "✅ Created temporary files (should not be in container)"
```

### Learning Chunk 2C: Create Development Files

```bash
echo ""
echo "=== Creating Development-Only Files ==="
echo "These files are needed for development but not production"

# Create development files
mkdir .git
echo "Git repository data" > .git/config
echo "ref: refs/heads/main" > .git/HEAD

echo "✅ Created .git directory (version control - not needed in container)"

# Create documentation
mkdir docs
echo "# Project Documentation" > docs/README.md
echo "## Installation Guide" > docs/INSTALL.md

echo "✅ Created docs directory (documentation - not needed in container)"

# Create node_modules simulation
mkdir node_modules_dev
echo "Development dependencies" > node_modules_dev/dev-package.js
echo "Testing frameworks" > node_modules_dev/test-framework.js

echo "✅ Created development dependencies (should not be in container)"
```

### Learning Chunk 2D: See Current Directory State

```bash
echo ""
echo "=== Current Directory Analysis ==="
echo "📁 Let's see what we have in our project directory:"

ls -la

echo ""
echo "📊 Directory size analysis:"
du -sh * 2>/dev/null || echo "Calculating sizes..."

echo ""
echo "🚨 PROBLEM DEMONSTRATION:"
echo "All these files would be sent to Docker build context"
echo "This slows builds and may include sensitive data"
```

### Learning Chunk 2E: Build Without .dockerignore

```bash
echo ""
echo "=== Building WITHOUT .dockerignore ==="
echo "⚠️  This will include ALL files in build context"
echo "Watch the 'Sending build context' message..."

# Build without .dockerignore to see the problem
docker build -f Dockerfile.optimized -t webapp-with-junk:v1 .

echo ""
echo "💡 OBSERVATION:"
echo "Notice the 'Sending build context to Docker daemon' size"
echo "It includes ALL files in the directory!"
```

### Learning Chunk 2F: Create .dockerignore File

```bash
echo ""
echo "=== Creating .dockerignore File ==="
echo "📋 Now let's create a comprehensive .dockerignore file"
echo "This will exclude unnecessary files from build context"

# Create a comprehensive .dockerignore file
cat > .dockerignore << 'EOF'
# Logs
logs/
*.log

# Temporary files
*.tmp
temp.txt

# Version control
.git/
.gitignore

# Development dependencies
node_modules_dev/

# Documentation (not needed in production)
docs/
README.md

# IDE files
.vscode/
.idea/

# OS generated files
.DS_Store
Thumbs.db

# Docker files (don't include other Dockerfiles)
Dockerfile.*
!Dockerfile.optimized

# Build artifacts
dist/
build/
*.out
EOF

echo "✅ Created comprehensive .dockerignore file"
echo "📋 Let's examine what we're excluding:"
cat .dockerignore
```

### Learning Chunk 2G: Build With .dockerignore

```bash
echo ""
echo "=== Building WITH .dockerignore ==="
echo "✅ Now the build context should be much smaller"
echo "Only necessary files will be sent to Docker daemon"

# Build the image with .dockerignore
docker build -f Dockerfile.optimized -t webapp-clean:v1 .

echo ""
echo "📊 BUILD CONTEXT COMPARISON:"
echo "Compare the 'Sending build context' sizes between builds"
echo "The difference should be significant!"
```

### Learning Chunk 2H: Verify .dockerignore Effect

```bash
echo ""
echo "=== Verifying .dockerignore Effectiveness ==="
echo "Let's check what files actually made it into the image"

# Check what files are in the image
echo "📁 Files in the nginx html directory:"
docker run --rm webapp-clean:v1 ls -la /usr/share/nginx/html/

echo ""
echo "🔍 Checking if excluded files are absent:"
docker run --rm webapp-clean:v1 ls -la / | grep -E "(logs|docs|temp)" || echo "✅ Excluded files are not in the container"

echo ""
echo "💡 SUCCESS ANALYSIS:"
echo "Only index.html should be in /usr/share/nginx/html/"
echo "No logs/, docs/, or temporary files should be present"
```

---

## Task 3: Build Custom Images with Proper Tagging

### Learning Chunk 3A: Understanding Docker Tagging

```bash
echo ""
echo "=== TASK 3: Custom Image Building and Tagging ==="
echo "🎯 LEARNING GOAL: Master Docker image tagging strategies"
echo ""
echo "TAGGING CONCEPTS:"
echo "• Tags are aliases for image IDs"
echo "• Format: [registry/]name[:tag]"
echo "• Default tag is 'latest'"
echo "• Semantic versioning: major.minor.patch"
echo "• Environment tags: dev, staging, prod"
echo ""
echo "WHY PROPER TAGGING MATTERS:"
echo "• Organize different versions"
echo "• Support multiple environments"
echo "• Enable rollback strategies"
echo "• Communicate image purpose"
```

### Learning Chunk 3B: Create Production-Ready Dockerfile

```bash
echo ""
echo "=== Creating Production-Ready Dockerfile ==="
echo "This will be our final, production-ready image with:"
echo "• Metadata labels for documentation"
echo "• Security headers configuration"
echo "• Custom nginx configuration"

# Create a final optimized Dockerfile
cat > Dockerfile << 'EOF'
FROM nginx:alpine

# Add metadata labels
LABEL maintainer="your-email@example.com"
LABEL version="1.0"
LABEL description="Optimized web application for Docker lab"

# Copy application files
COPY index.html /usr/share/nginx/html/

# Create custom nginx configuration
RUN echo 'server { \
    listen 80; \
    server_name localhost; \
    location / { \
        root /usr/share/nginx/html; \
        index index.html; \
    } \
    # Security headers \
    add_header X-Frame-Options "SAMEORIGIN" always; \
    add_header X-Content-Type-Options "nosniff" always; \
}' > /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
EOF

echo "✅ Created production-ready Dockerfile"
echo "🔒 SECURITY FEATURES:"
echo "• X-Frame-Options prevents clickjacking"
echo "• X-Content-Type-Options prevents MIME sniffing"
echo "📝 METADATA LABELS help with image management"
```

### Learning Chunk 3C: Build with Semantic Versioning

```bash
echo ""
echo "=== Building with Semantic Versioning ==="
echo "📊 SEMANTIC VERSIONING (SemVer):"
echo "• Format: MAJOR.MINOR.PATCH (e.g., 1.0.0)"
echo "• MAJOR: Breaking changes"
echo "• MINOR: New features, backward compatible"
echo "• PATCH: Bug fixes, backward compatible"

# Build with version tag
docker build -t mywebapp:1.0.0 .

echo "✅ Built mywebapp:1.0.0"
echo "This is our specific version that will never change"
```

### Learning Chunk 3D: Create Multiple Tag Aliases

```bash
echo ""
echo "=== Creating Tag Aliases ==="
echo "One image can have multiple tags pointing to it"
echo "This allows different naming strategies for the same image"

# Tag the same image with different tags
docker tag mywebapp:1.0.0 mywebapp:1.0
echo "✅ Tagged as 1.0 (minor version alias)"

docker tag mywebapp:1.0.0 mywebapp:latest
echo "✅ Tagged as latest (default tag)"

docker tag mywebapp:1.0.0 mywebapp:stable
echo "✅ Tagged as stable (indicates tested version)"

echo ""
echo "📊 All tags for our image:"
# View all tags
docker images mywebapp
```

### Learning Chunk 3E: Environment-Specific Tagging

```bash
echo ""
echo "=== Environment-Specific Tagging ==="
echo "Different environments often need different image references"
echo "This helps with deployment automation and environment management"

# Development version
docker tag mywebapp:1.0.0 mywebapp:dev
echo "✅ Tagged for development environment"

# Staging version
docker tag mywebapp:1.0.0 mywebapp:staging
echo "✅ Tagged for staging environment"

# Production version
docker tag mywebapp:1.0.0 mywebapp:prod
echo "✅ Tagged for production environment"

echo ""
echo "📊 Complete tag overview:"
docker images mywebapp --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
```

### Learning Chunk 3F: Test Local Image

```bash
echo ""
echo "=== Testing the Image Locally ==="
echo "Before pushing to registry, let's verify everything works"

# Run the container
docker run -d -p 8080:80 --name webapp-test mywebapp:latest

echo "✅ Started container on port 8080"
echo "⏳ Waiting for container to fully start..."
sleep 3

# Test the application
echo ""
echo "🌐 Testing HTTP response:"
curl -I http://localhost:8080

echo ""
echo "📄 Testing HTML content:"
curl -s http://localhost:8080 | grep -o "<title>.*</title>" || echo "HTML content verified"
```

### Learning Chunk 3G: Monitor and Verify Container

```bash
echo ""
echo "=== Container Health Verification ==="

# Check container logs
echo "📋 Container startup logs:"
docker logs webapp-test

echo ""
echo "📊 Container resource usage:"
# Check resource usage briefly
docker stats webapp-test --no-stream

echo ""
echo "🔍 Container process verification:"
docker exec webapp-test ps aux

# Stop and remove the test container
echo ""
echo "🧹 Cleaning up test container..."
docker stop webapp-test
docker rm webapp-test

echo "✅ Local testing completed successfully!"
```

---

## Task 4: Push Images to Docker Hub

### Learning Chunk 4A: Docker Hub Overview and Login

```bash
echo ""
echo "=== TASK 4: Pushing Images to Docker Hub ==="
echo "🎯 LEARNING GOAL: Share images via Docker Registry"
echo ""
echo "DOCKER HUB CONCEPTS:"
echo "• Central registry for Docker images"
echo "• Like GitHub but for containers"
echo "• Public and private repositories"
echo "• Automatic builds from Git repositories"
echo ""
echo "⚠️  PREREQUISITE: You need a Docker Hub account"
echo "Create one at https://hub.docker.com if you don't have it"
echo ""
echo "🔐 Now let's login to Docker Hub..."

# Login to Docker Hub
docker login

echo ""
echo "✅ Login successful!"
echo "Docker stores credentials securely for this session"
```

### Learning Chunk 4B: Tag for Docker Hub

```bash
echo ""
echo "=== Tagging Images for Docker Hub ==="
echo "📝 DOCKER HUB NAMING CONVENTION:"
echo "• Format: username/repository:tag"
echo "• username: Your Docker Hub username"
echo "• repository: Your image name"
echo "• tag: Version or variant identifier"
echo ""
echo "🏷️  Tagging our image for Docker Hub..."
echo "⚠️  IMPORTANT: Replace 'yourusername' with your actual Docker Hub username!"

read -p "Enter your Docker Hub username: " DOCKER_USERNAME

# Tag image for Docker Hub
docker tag mywebapp:1.0.0 ${DOCKER_USERNAME}/mywebapp:1.0.0
echo "✅ Tagged specific version for Docker Hub"

docker tag mywebapp:1.0.0 ${DOCKER_USERNAME}/mywebapp:latest
echo "✅ Tagged latest version for Docker Hub"

echo ""
echo "📊 Docker Hub ready images:"
docker images ${DOCKER_USERNAME}/mywebapp
```

### Learning Chunk 4C: Push Specific Version

```bash
echo ""
echo "=== Pushing Specific Version to Docker Hub ==="
echo "🚀 Uploading the specific version first..."
echo "This creates the repository and uploads all layers"

# Push specific version
docker push ${DOCKER_USERNAME}/mywebapp:1.0.0

echo ""
echo "✅ Successfully pushed version 1.0.0!"
echo "🌐 Your image is now publicly available on Docker Hub"
```

### Learning Chunk 4D: Push Latest Tag

```bash
echo ""
echo "=== Pushing Latest Tag ==="
echo "🚀 Now pushing the 'latest' tag..."
echo "This will reuse layers already uploaded (much faster)"

# Push latest tag
docker push ${DOCKER_USERNAME}/mywebapp:latest

echo ""
echo "✅ Successfully pushed latest tag!"
echo "📊 Your repository now has multiple tags available"
```

### Learning Chunk 4E: Verify Docker Hub Push

```bash
echo ""
echo "=== Verifying Docker Hub Repository ==="
echo "🔍 Let's verify our images are available on Docker Hub"

# Check your repositories
echo "🔎 Searching for your image on Docker Hub:"
docker search ${DOCKER_USERNAME}/mywebapp

echo ""
echo "🌐 VERIFICATION METHODS:"
echo "1. Visit https://hub.docker.com/r/${DOCKER_USERNAME}/mywebapp"
echo "2. Check the 'Tags' tab for your uploaded versions"
echo "3. Verify the image size and upload time"
echo ""
echo "📈 DOCKER HUB BENEFITS:"
echo "• Global CDN for fast image pulls"
echo "• Automated vulnerability scanning"
echo "• Webhook integrations for CI/CD"
echo "• Download statistics and analytics"
```

### Learning Chunk 4F: Create Repository Documentation

```bash
echo ""
echo "=== Creating Docker Hub Documentation ==="
echo "📖 Good documentation helps users understand your image"
echo "Docker Hub can automatically display README content"

# Create a README for Docker Hub repository
cat > DOCKER_README.md << 'EOF'
# MyWebApp Docker Image

A simple, optimized web application built for Docker demonstration.

## Features
- Based on nginx:alpine for minimal size
- Optimized with multi-layer reduction
- Security headers included
- Production-ready configuration

## Usage

```bash
docker run -d -p 80:80 yourusername/mywebapp:latest
```

## Tags
- `latest` - Latest stable version
- `1.0.0` - Specific version
- `stable` - Stable release

## Size
Approximately 15MB (optimized from 200MB+ unoptimized version)

## Security Features
- X-Frame-Options header for clickjacking protection
- X-Content-Type-Options header for MIME sniffing protection
- Runs on nginx:alpine (security-focused minimal distribution)
EOF

echo "✅ Created comprehensive Docker Hub README"
echo "📖 Copy this content to your Docker Hub repository description"
echo "🌐 This will be displayed on your Docker Hub page"
```

---

## Task 5: Pull and Run Images on Different Machines

### Learning Chunk 5A: Simulating Fresh Environment

```bash
echo ""
echo "=== TASK 5: Image Portability and Distribution ==="
echo "🎯 LEARNING GOAL: Demonstrate container portability"
echo ""
echo "REAL-WORLD SCENARIO:"
echo "• Development team builds image"
echo "• QA team pulls and tests on different environment"
echo "• Production team deploys on production servers"
echo "• All environments get identical application"
echo ""
echo "🧹 Simulating fresh environment by cleaning local images..."

# Stop any running containers
docker stop $(docker ps -q) 2>/dev/null || echo "No containers to stop"

echo "✅ Stopped all running containers"
```

### Learning Chunk 5B: Clean Local Environment

```bash
echo ""
echo "=== Cleaning Local Environment ==="
echo "Removing local copies to simulate pulling on a fresh machine"

# Remove local images (keep the pushed ones on Docker Hub)
docker rmi mywebapp:1.0.0 mywebapp:latest mywebapp:stable 2>/dev/null || echo "Some images already removed"
docker rmi mywebapp:dev mywebapp:staging mywebapp:prod 2>/dev/null || echo "Environment tags cleaned"
docker rmi ${DOCKER_USERNAME}/mywebapp:1.0.0 ${DOCKER_USERNAME}/mywebapp:latest 2>/dev/null || echo "Docker Hub tags cleaned locally"

echo ""
echo "🔍 Verifying local images are removed:"
# Verify images are removed
docker images | grep mywebapp || echo "✅ No local mywebapp images found - simulation successful!"
```

### Learning Chunk 5C: Pull from Docker Hub

```bash
echo ""
echo "=== Pulling Images from Docker Hub ==="
echo "🌐 Now we're acting like a fresh machine downloading our image"
echo "This could be a production server anywhere in the world"

# Pull latest version
echo "📥 Pulling latest version..."
docker pull ${DOCKER_USERNAME}/mywebapp:latest

echo ""
# Pull specific version
echo "📥 Pulling specific version..."
docker pull ${DOCKER_USERNAME}/mywebapp:1.0.0

echo ""
echo "✅ Images successfully pulled from Docker Hub!"
```

### Learning Chunk 5D: Verify Pulled Images

```bash
echo ""
echo "=== Verifying Pulled Images ==="
echo "📊 Let's confirm our images are now available locally"

# Verify the pulled images
docker images ${DOCKER_USERNAME}/mywebapp

echo ""
echo "🔍 IMAGE ANALYSIS:"
echo "• Same image ID means identical content"
echo "• Size should match what we pushed"
echo "• Multiple tags can point to same image ID"
echo "• Creation date shows when originally built"
```

### Learning Chunk 5E: Run Pulled Image in Production Mode

```bash
echo ""
echo "=== Running Production Deployment ==="
echo "🚀 Deploying as if this were a production server"

# Run in production mode with specific settings
docker run -d \
  -p 8080:80 \
  --name production-webapp \
  --restart unless-stopped \
  ${DOCKER_USERNAME}/mywebapp:latest

echo "✅ Production container started with:"
echo "• Port 8080 mapped to container port 80"
echo "• Restart policy: unless-stopped"
echo "• Named 'production-webapp' for management"

echo ""
echo "⏳ Waiting for application to fully start..."
sleep 3
```

### Learning Chunk 5F: Test Production Deployment

```bash
echo ""
echo "=== Testing Production Deployment ==="

# Test with curl
echo "🌐 Testing HTTP connectivity:"
curl -I http://localhost:8080

echo ""
echo "📄 Verifying HTML content delivery:"
curl -s http://localhost:8080 | grep "Docker Optimization Lab" && echo "✅ Content verified!" || echo "❌ Content check failed"

echo ""
echo "🔒 Testing security headers:"
curl -I http://localhost:8080 | grep -E "(X-Frame-Options|X-Content-Type-Options)" || echo "Security headers verified"
```

### Learning Chunk 5G: Monitor Production Container

```bash
echo ""
echo "=== Production Monitoring ==="

# Check container status
echo "📊 Container status:"
docker ps --filter name=production-webapp

echo ""
echo "📋 Container logs (last 10 lines):"
# View container logs
docker logs --tail 10 production-webapp

echo ""
echo "⚡ Real-time resource monitoring:"
# Check resource usage
docker stats production-webapp --no-stream

echo ""
echo "🔍 Container process inspection:"
docker exec production-webapp ps aux | head -5
```

### Learning Chunk 5H: Advanced Deployment Scenarios

```bash
echo ""
echo "=== Advanced Deployment Scenarios ==="
echo "🎓 REAL-WORLD DEPLOYMENT PATTERNS:"
echo "• Custom environment variables"
echo "• Volume mounting for persistent data"
echo "• Network configuration"
echo "• Health checks and monitoring"

echo ""
echo "📋 Scenario 1: Custom Environment Configuration"
# Run with environment variables
docker run -d -p 8081:80 \
  --name webapp-custom \
  -e NGINX_HOST=localhost \
  -e NGINX_PORT=80 \
  ${DOCKER_USERNAME}/mywebapp:latest

echo "✅ Started webapp-custom with environment variables"
```

### Learning Chunk 5I: Volume Mounting Scenario

```bash
echo ""
echo "=== Volume Mounting for Custom Content ==="
echo "📁 Scenario 2: Adding custom content via volumes"
echo "This simulates mounting configuration or dynamic content"

# Create custom content
mkdir -p custom-content
echo "<h1>Custom Content</h1><p>This content is mounted from the host!</p>" > custom-content/custom.html

echo "✅ Created custom content directory"

# Run with volume
docker run -d -p 8082:80 \
  --name webapp-volume \
  -v $(pwd)/custom-content:/usr/share/nginx/html/custom \
  ${DOCKER_USERNAME}/mywebapp:latest

echo "✅ Started webapp-volume with custom content mounted"
echo "🌐 Custom content will be available at /custom/custom.html"
```

### Learning Chunk 5J: Test All Deployments

```bash
echo ""
echo "=== Testing All Deployment Scenarios ==="

# Test original deployment
echo "🧪 Testing original deployment (port 8080):"
curl -s http://localhost:8080 | grep -o "<title>.*</title>" && echo "✅ Original deployment working"

echo ""
# Test custom deployment
echo "🧪 Testing custom environment deployment (port 8081):"
curl -I http://localhost:8081 | head -1

echo ""
# Test volume deployment
echo "🧪 Testing volume mounted deployment (port 8082):"
curl -s http://localhost:8082/custom/custom.html | grep "Custom Content" && echo "✅ Volume mounting working" || echo "⚠️ Volume test - check custom content"

echo ""
echo "📊 All running containers:"
docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}"
```

---

## Troubleshooting and Best Practices

### Learning Chunk 6A: Common Issues and Solutions

```bash
echo ""
echo "=== TROUBLESHOOTING COMMON ISSUES ==="
echo "🔧 Essential debugging skills for Docker image management"

echo ""
echo "Issue 1: Docker Login Problems"
echo "💡 SOLUTION STEPS:"

# If login fails, try:
echo "🔐 If login fails, try these steps:"
echo "1. Logout first: docker logout"
echo "2. Login again: docker login --username yourusername"
echo "3. Check credentials carefully"
```

### Learning Chunk 6B: Push Permission Issues

```bash
echo ""
echo "Issue 2: Push Permission Denied"
echo "💡 COMMON CAUSES AND SOLUTIONS:"

echo "🚨 If you get 'permission denied' when pushing:"
echo "1. Verify you're pushing to YOUR repository"
echo "2. Check the image tag includes your username"
echo "3. Ensure you're logged in to correct account"

echo ""
echo "✅ Correct format example:"
echo "docker tag mywebapp:latest ${DOCKER_USERNAME}/mywebapp:latest"
echo "docker push ${DOCKER_USERNAME}/mywebapp:latest"
```

### Learning Chunk 6C: Port Conflicts

```bash
echo ""
echo "Issue 3: Port Already in Use"
echo "💡 DIAGNOSIS AND RESOLUTION:"

# Find what's using the port
echo "🔍 To find what's using port 8080:"
echo "sudo netstat -tulpn | grep :8080"

echo ""
echo "🔧 Solutions:"
echo "1. Use different port: docker run -d -p 8090:80 ..."
echo "2. Stop conflicting service"
echo "3. Kill process using the port"

echo ""
echo "🧪 Testing port availability:"
sudo netstat -tulpn | grep :8080 || echo "✅ Port 8080 appears to be available"
```

### Learning Chunk 6D: Container Startup Issues

```bash
echo ""
echo "Issue 4: Container Won't Start"
echo "💡 DEBUGGING TECHNIQUES:"

echo "🔍 Essential debugging commands:"
echo "1. Check logs: docker logs container-name"
echo "2. Run interactively: docker run -it image-name /bin/sh"
echo "3. Check image layers: docker history image-name"
echo "4. Inspect configuration: docker inspect container-name"

echo ""
echo "🧪 Let's demonstrate interactive debugging:"
echo "If a container fails to start, you can run it interactively:"
echo "docker run -it ${DOCKER_USERNAME}/mywebapp:latest /bin/sh"
echo "(This would give you a shell inside the container to investigate)"
```

### Learning Chunk 6E: Image Management Best Practices

```bash
echo ""
echo "=== IMAGE MANAGEMENT BEST PRACTICES ==="
echo "🏆 PRODUCTION-READY STRATEGIES:"

echo ""
echo "1. 🏷️  TAGGING STRATEGY:"
echo "• Use semantic versioning (1.2.3)"
echo "• Tag environment-specific versions"
echo "• Never rely solely on 'latest' tag"
echo "• Include build date/commit in tags for traceability"

echo ""
echo "2. 📦 SIZE OPTIMIZATION:"
echo "• Use alpine-based images when possible"
echo "• Multi-stage builds for compiled applications"
echo "• .dockerignore to exclude unnecessary files"
echo "• Combine RUN commands to reduce layers"

echo ""
echo "3. 🔒 SECURITY PRACTICES:"
echo "• Regular base image updates"
echo "• Run as non-root user when possible"
echo "• Scan images for vulnerabilities"
echo "• Use trusted base images only"
```

### Learning Chunk 6F: Performance Monitoring

```bash
echo ""
echo "=== Performance Monitoring and Optimization ==="

echo "📊 Checking current container performance:"
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}"

echo ""
echo "💾 Docker system resource usage:"
docker system df

echo ""
echo "🔍 Detailed image analysis:"
echo "Image layer breakdown for our optimized image:"
docker history ${DOCKER_USERNAME}/mywebapp:latest --format "table {{.CreatedBy}}\t{{.Size}}"
```

---

## Complete Lab Cleanup

### Learning Chunk 7A: Organized Cleanup Process

```bash
echo ""
echo "=== COMPLETE LAB CLEANUP ==="
echo "🧹 Properly cleaning up all resources created in this lab"
echo "This demonstrates good Docker hygiene practices"

echo ""
echo "Step 1: Stop all running containers"
# Stop all containers
echo "🛑 Stopping containers gracefully..."
docker stop $(docker ps -q) 2>/dev/null || echo "No containers to stop"

echo ""
echo "Step 2: Remove containers"
# Remove containers
echo "🗑️  Removing containers..."
docker rm $(docker ps -aq) 2>/dev/null || echo "No containers to remove"
```

### Learning Chunk 7B: Image Cleanup

```bash
echo ""
echo "Step 3: Remove local images (optional)"
echo "⚠️  This removes all local images - your Docker Hub images remain safe"

# List what we're about to remove
echo "📋 Images that will be removed:"
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

echo ""
read -p "🤔 Remove all local images? (y/N): " -r
if [[ $REPLY =~ ^[Yy]$ ]]; then
    # Remove images
    docker rmi $(docker images -q) 2>/dev/null || echo "Some images may be in use"
    echo "✅ Local images removed"
else
    echo "👍 Keeping local images"
fi
```

### Learning Chunk 7C: System Cleanup

```bash
echo ""
echo "Step 4: Clean up Docker system resources"

# Clean up build cache and unused resources
echo "🧹 Cleaning Docker build cache and unused resources..."
docker system prune -f

echo ""
echo "📊 Final system state:"
docker system df

echo ""
echo "🧹 Optional: Clean up volumes (removes persistent data)"
echo "docker volume prune -f"

echo ""
echo "📁 Cleaning up project files:"
cd ..
rm -rf docker-optimization-lab
echo "✅ Project directory removed"
```

---

## Lab Summary and Learning Outcomes

### Learning Chunk 8A: What You've Mastered

```bash
echo ""
echo "=== LAB COMPLETION SUMMARY ==="
echo "🎉 CONGRATULATIONS! You have successfully mastered:"

echo ""
echo "✅ IMAGE OPTIMIZATION:"
echo "• Reduced image sizes by 80-90% using alpine base images"
echo "• Combined multiple RUN commands to reduce layers"
echo "• Implemented multi-stage builds for complex applications"

echo ""
echo "✅ BUILD CONTEXT MANAGEMENT:"
echo "• Created comprehensive .dockerignore files"
echo "• Excluded unnecessary files from builds"
echo "• Improved build speed and security"

echo ""
echo "✅ TAGGING STRATEGIES:"
echo "• Semantic versioning (1.0.0)"
echo "• Environment-specific tags (dev, staging, prod)"
echo "• Multiple aliases for same image"

echo ""
echo "✅ REGISTRY MANAGEMENT:"
echo "• Pushed images to Docker Hub"
echo "• Pulled images on simulated different machines"
echo "• Demonstrated container portability"

echo ""
echo "✅ PRODUCTION DEPLOYMENT:"
echo "• Multiple deployment scenarios"
echo "• Volume mounting for dynamic content"
echo "• Environment variable configuration"
echo "• Container monitoring and debugging"
```

### Learning Chunk 8B: Real-World Applications

```bash
echo ""
echo "=== REAL-WORLD APPLICATIONS ==="
echo "🌍 These skills are essential for:"

echo ""
echo "🏢 ENTERPRISE ENVIRONMENTS:"
echo "• Microservices architecture"
echo "• CI/CD pipeline integration"
echo "• Multi-environment deployments"
echo "• Container orchestration platforms"

echo ""
echo "📈 PERFORMANCE BENEFITS:"
echo "• Faster deployments (smaller images)"
echo "• Reduced storage costs"
echo "• Improved security posture"
echo "• Better resource utilization"

echo ""
echo "🔧 DEVOPS PRACTICES:"
echo "• Infrastructure as Code"
echo "• Immutable deployments"
echo "• Version control for applications"
echo "• Automated testing and deployment"
```

### Learning Chunk 8C: Next Steps and Advanced Learning

```bash
echo ""
echo "=== NEXT STEPS FOR CONTINUED LEARNING ==="
echo "🎓 Advanced topics to explore:"

echo ""
echo "🚀 CONTAINER ORCHESTRATION:"
echo "• Docker Swarm for clustering"
echo "• Kubernetes for enterprise orchestration"
echo "• Docker Compose for multi-container applications"

echo ""
echo "🔒 SECURITY ADVANCED:"
echo "• Container security scanning"
echo "• Runtime security monitoring"
echo "• Secrets management"
echo "• Network security policies"

echo ""
echo "⚡ PERFORMANCE OPTIMIZATION:"
echo "• Container resource limits"
echo "• Health checks and monitoring"
echo "• Load balancing strategies"
echo "• Caching mechanisms"

echo ""
echo "🎯 CERTIFICATION PREPARATION:"
echo "• Docker Certified Associate (DCA)"
echo "• Kubernetes certifications (CKA, CKAD)"
echo "• Cloud platform container certifications"

echo ""
echo "✨ CONGRATULATIONS ON COMPLETING THE DOCKER IMAGE LAB!"
echo "You now have production-ready Docker skills! 🐳"
```

## Quick Reference Commands

```bash
echo ""
echo "=== QUICK REFERENCE GUIDE ==="
echo "Essential commands for daily Docker image management:"

echo ""
echo "📦 BUILD COMMANDS:"
echo "docker build -t name:tag .                    # Build image"
echo "docker build -f Dockerfile.custom -t name .   # Build with specific Dockerfile"
echo "docker history image-name                     # View image layers"

echo ""
echo "🏷️  TAGGING COMMANDS:"
echo "docker tag source-image target-image          # Create tag"
echo "docker images                                  # List all images"
echo "docker rmi image-name                          # Remove image"

echo ""
echo "🌐 REGISTRY COMMANDS:"
echo "docker login                                   # Login to registry"
echo "docker push username/image:tag                # Push to registry"
echo "docker pull username/image:tag                # Pull from registry"

echo ""
echo "🔧 DEBUGGING COMMANDS:"
echo "docker logs container-name                    # View logs"
echo "docker exec -it container-name /bin/sh        # Interactive shell"
echo "docker inspect image-or-container             # Detailed info"

echo ""
echo "🧹 CLEANUP COMMANDS:"
echo "docker system prune                           # Clean unused resources"
echo "docker image prune                            # Clean unused images"
echo "docker container prune                        # Clean stopped containers"
```

## Files and Artifacts Created

```bash
echo ""
echo "=== LAB ARTIFACTS SUMMARY ==="
echo "📁 Files created during this lab:"
echo "• index.html - Sample web application"
echo "• Dockerfile.unoptimized - Example of poor practices"
echo "• Dockerfile.optimized - Optimized version"
echo "• Dockerfile.multistage - Advanced multi-stage build"
echo "• Dockerfile - Production-ready final version"
echo "• .dockerignore - Build context exclusion rules"
echo "• package.json & server.js - Node.js application example"
echo "• DOCKER_README.md - Docker Hub documentation"

echo ""
echo "🏷️ Image tags created:"
echo "• webapp-unoptimized:v1"
echo "• webapp-optimized:v1"
echo "• webapp-multistage:v1"
echo "• mywebapp:1.0.0 (and various aliases)"
echo "• ${DOCKER_USERNAME}/mywebapp:1.0.0 (on Docker Hub)"
echo "• ${DOCKER_USERNAME}/mywebapp:latest (on Docker Hub)"

echo ""
echo "🎯 This completes your comprehensive Docker image management education!"
```
